# -*- coding: utf-8 -*-

"""
The free rigid category, i.e. diagrams with cups and caps.

Summary
-------

.. autosummary::
    :template: class.rst
    :nosignatures:
    :toctree:

    Ob
    Ty
    Diagram
    Box
    Cup
    Cap
    Sum
    Category
    Functor

Axioms
------

>>> unit, s, n = Ty(), Ty('s'), Ty('n')
>>> t = n.r @ s @ n.l
>>> assert t @ unit == t == unit @ t
>>> assert t.l.r == t == t.r.l
>>> left_snake, right_snake = Id(n.r).transpose(left=True), Id(n.l).transpose()
>>> assert left_snake.normal_form() == Id(n) == right_snake.normal_form()
>>> from discopy import drawing
>>> drawing.equation(
...     left_snake, Id(n), right_snake, figsize=(4, 2),
...     path='docs/imgs/rigid/snake-equation.png')

.. image:: /imgs/rigid/snake-equation.png
    :align: center
"""

from __future__ import annotations
from collections.abc import Callable

from discopy import cat, monoidal, closed, messages, rewriting
from discopy.cat import AxiomError, factory
from discopy.monoidal import Encoding
from discopy.utils import (
    BinaryBoxConstructor,
    assert_isinstance,
    assert_isatomic,
    factory_name,
)


class Ob(cat.Ob):
    """
    A rigid object has adjoints :meth:`Ob.l` and :meth:`Ob.r`.

    Parameters:
        name : The name of the object.
        z : The winding number.

    Example
    -------
    >>> a = Ob('a')
    >>> assert a.l.r == a.r.l == a and a != a.l.l != a.r.r
    """
    __ambiguous_inheritance__ = True

    def __init__(self, name: str, z: int = 0):
        assert_isinstance(z, int)
        self.z = z
        super().__init__(name)

    @property
    def l(self) -> Ob:
        """ The left adjoint of the object. """
        return type(self)(self.name, self.z - 1)

    @property
    def r(self) -> Ob:
        """ The right adjoint of the object. """
        return type(self)(self.name, self.z + 1)

    def __eq__(self, other):
        return isinstance(other, Ob)\
            and cat.Ob.__eq__(self, other) and self.z == other.z

    def __hash__(self):
        return hash(self.name if not self.z else (self.name, self.z))

    def __repr__(self):
        return "{}({}{})".format(
            factory_name(type(self)), repr(self.name),
            ", z=" + repr(self.z) if self.z else "")

    def __str__(self):
        return str(self.name) + (
            - self.z * '.l' if self.z < 0 else self.z * '.r')

    def to_tree(self):
        tree = super().to_tree()
        if self.z:
            tree['z'] = self.z
        return tree

    @classmethod
    def from_tree(cls, tree):
        name, z = tree['name'], tree.get('z', 0)
        return cls(name=name, z=z)


@factory
class Ty(closed.Ty):
    """
    A rigid type is a closed type with rigid objects inside.

    Parameters:
        inside (tuple[Ob, ...]) : The objects inside the type.

    Example
    -------
    >>> s, n = Ty('s'), Ty('n')
    >>> assert n.l.r == n == n.r.l
    >>> assert (s @ n).l == n.l @ s.l and (s @ n).r == n.r @ s.r
    """
    def assert_isadjoint(self, other):
        """
        Raise ``AxiomError`` if two rigid types are not adjoints.

        Parameters:
            other : The alleged right adjoint.
        """
        if self.r != other and self != other.r:
            raise AxiomError(messages.NOT_ADJOINT.format(self, other))
        if self.r != other:
            raise AxiomError(messages.NOT_RIGID_ADJOINT.format(self, other))

    @property
    def l(self) -> Ty:
        """ The left adjoint of the type. """
        return self.factory(*[x.l for x in self.inside[::-1]])

    @property
    def r(self) -> Ty:
        """ The right adjoint of the type. """
        return self.factory(*[x.r for x in self.inside[::-1]])

    @property
    def z(self) -> int:
        """ The winding number is only defined for types of length 1. """
        assert_isatomic(self)
        return self.inside[0].z

    def __lshift__(self, other):
        return self @ other.l

    def __rshift__(self, other):
        return self.r @ other

    ob_factory = Ob


@factory
class PRO(monoidal.PRO, Ty):
    """ Objects of the free rigid monoidal category generated by 1. """
    __ambiguous_inheritance__ = (monoidal.PRO, )
    l = r = property(lambda self: self)


@factory
class Diagram(closed.Diagram):
    """
    A rigid diagram is a closed diagram
    with :class:`Cup` and :class:`Cap` boxes.

    Parameters:
        inside (tuple[Layer, ...]) : The layers of the diagram.
        dom (Ty) : The domain of the diagram, i.e. its input.
        cod (Ty) : The codomain of the diagram, i.e. its output.

    Example
    -------
    >>> I, n, s = Ty(), Ty('n'), Ty('s')
    >>> Alice, jokes = Box('Alice', I, n), Box('jokes', I, n.r @ s)
    >>> d = Alice >> Id(n) @ jokes >> Cup(n, n.r) @ Id(s)
    >>> d.draw(figsize=(3, 2),
    ...        path='docs/imgs/rigid/diagram-example.png')

    .. image:: /imgs/rigid/diagram-example.png
        :align: center
    """
    __ambiguous_inheritance__ = True

    def dagger(self):
        """
        The dagger of a rigid diagram is ill-defined,
        use a :class:`pivotal.Diagram` instead.
        """
        raise AxiomError("Rigid diagrams have no dagger, use pivotal instead.")

    over = staticmethod(lambda base, exponent: base << exponent)
    under = staticmethod(lambda base, exponent: exponent >> base)

    @classmethod
    def eval(cls, base: Ty, exponent: Ty, left=True) -> Diagram:
        return base @ cls.cups(exponent.l, exponent) if left\
            else cls.cups(exponent, exponent.r) @ base

    @classmethod
    def cups(cls, left: Ty, right: Ty) -> Diagram:
        """
        Construct a diagram of nested cups for types ``left`` and ``right``.

        Parameters:
            left : The type left of the cup.
            right : Its right adjoint.

        Example
        -------
        >>> a, b = Ty('a'), Ty('b')
        >>> Diagram.cups(a.l @ b, b.r @ a).draw(figsize=(3, 1),\\
        ... margins=(0.3, 0.05), path='docs/imgs/rigid/cups.png')

        .. image:: /imgs/rigid/cups.png
            :align: center
        """
        return nesting(cls, cls.cup_factory)(left, right)

    @classmethod
    def caps(cls, left: Ty, right: Ty) -> Diagram:
        """
        Construct a diagram of nested caps for types ``left`` and ``right``.

        Parameters:
            left : The type left of the cap.
            right : Its left adjoint.

        Example
        -------
        >>> a, b = Ty('a'), Ty('b')
        >>> Diagram.caps(a.r @ b, b.l @ a).draw(figsize=(3, 1),\\
        ... margins=(0.3, 0.05), path='docs/imgs/rigid/caps.png')

        .. image:: /imgs/rigid/caps.png
            :align: center
        """
        return nesting(cls, cls.cap_factory)(left, right)

    @staticmethod
    def fa(left, right):
        return left @ Diagram.cups(right.l, right)

    @staticmethod
    def ba(left, right):
        return Diagram.cups(left, left.r) @ right

    @staticmethod
    def fc(left, middle, right):
        return left @ Diagram.cups(middle.l, middle) @ right.l

    @staticmethod
    def bc(left, middle, right):
        return left.r @ Diagram.cups(middle, middle.r) @ right

    @staticmethod
    def fx(left, middle, right):
        return left @ Diagram.swap(middle.l, right.r) @ middle >>\
            Diagram.swap(left, right.r) @ Diagram.cups(middle.l, middle)

    @staticmethod
    def bx(left, middle, right):
        return middle @ Diagram.swap(left.l, middle.r) @ right >>\
            Diagram.cups(middle, middle.r) @ Diagram.swap(left.l, right)

    def curry(self, n=1, left=True) -> Diagram:
        if left:
            base, exponent = self.dom[:n], self.dom[n:]
            return base @ self.caps(exponent, exponent.l) >> self @ exponent.l
        offset = len(self.dom) - n
        base, exponent = self.dom[offset:], self.dom[:offset]
        return self.caps(exponent.r, exponent) @ base >> exponent.r @ self

    def rotate(self, left=False):
        """
        The half-turn rotation of a diagram, called with ``.l`` and ``.r``.

        Example
        -------
        >>> from discopy import drawing
        >>> x, y = map(Ty, "xy")
        >>> f = Box('f', Ty(), x)
        >>> g = Box('g', Ty(), x.r @ y)
        >>> diagram = f @ g >> Cup(x, x.r) @ y
        >>> LHS = drawing.Equation(diagram.l, diagram, symbol="$\\\\mapsfrom$")
        >>> RHS = drawing.Equation(LHS, diagram.r, symbol="$\\\\mapsto$")
        >>> RHS.draw(figsize=(8, 3), path='docs/imgs/rigid/rotate.png')

        .. image:: /imgs/rigid/rotate.png
            :align: center
        """
        dom, cod = (
            getattr(x, 'l' if left else 'r') for x in (self.cod, self.dom))
        inside = tuple(
            self.layer_factory(right.l, box.l, _left.l) if left
            else self.layer_factory(right.r, box.r, _left.r)
            for _left, box, right in self.inside[::-1])
        return self.factory(inside, dom, cod)

    l = property(lambda self: self.rotate(left=True))
    r = property(lambda self: self.rotate(left=False))

    def transpose(self, left=False):
        """
        The transpose of a diagram, i.e. its composition with cups and caps.

        Parameters:
            left : Whether to transpose left or right.

        Example
        -------
        >>> from discopy.drawing import Equation
        >>> x, y = map(Ty, "xy")
        >>> f = Box('f', x, y)
        >>> LHS = Equation(f.transpose(left=True), f, symbol="$\\\\mapsfrom$")
        >>> RHS = Equation(LHS, f.transpose(), symbol="$\\\\mapsto$")
        >>> RHS.draw(figsize=(8, 3), path="docs/imgs/rigid/transpose.png")

        .. image:: /imgs/rigid/transpose.png
        """
        if left:
            return self.cod.l @ self.caps(self.dom, self.dom.l)\
                >> self.cod.l @ self @ self.dom.l\
                >> self.cups(self.cod.l, self.cod) @ self.dom.l
        return self.caps(self.dom.r, self.dom) @ self.cod.r\
            >> self.dom.r @ self @ self.cod.r\
            >> self.dom.r @ self.cups(self.cod, self.cod.r)

    def transpose_box(self, i, left=False):
        """
        Transpose the box at index ``i``.

        Parameters:
            i : The index of the box to transpose.
            left : Whether to transpose left or right.

        Example
        -------
        >>> from discopy.drawing import Equation
        >>> x, y, z = map(Ty, "xyz")
        >>> f, g = Box('f', x, y), Box('g', y, z)
        >>> d = f >> g
        >>> transpose_l = d.transpose_box(0, left=True)
        >>> transpose_r = d.transpose_box(0, left=False)
        >>> LHS = Equation(transpose_l, d, symbol="$\\\\mapsfrom$")
        >>> RHS = Equation(LHS, transpose_r, symbol="$\\\\mapsto$")
        >>> RHS.draw(figsize=(8, 3), path="docs/imgs/rigid/transpose_box.png")

        .. image:: /imgs/rigid/transpose_box.png
        """
        _left, box, right = self.inside[i]
        transposed_box = (box.r if left else box.l).transpose(left)
        return self[:i] >> _left @ transposed_box @ right >> self[i + 1:]

    def draw(self, asymmetry=.25, **params):
        return super().draw(**dict(dict(asymmetry=asymmetry), **params))

    def normal_form(self, normalizer=None, **params):
        """
        Implements the normalisation of rigid monoidal categories,
        see arxiv:1601.05372, definition 2.12.

        Examples
        --------
        >>> a, b = Ty('a'), Ty('b')
        >>> double_snake = Id(a @ b).transpose()
        >>> two_snakes = Id(b).transpose() @ Id(a).transpose()
        >>> double_snake == two_snakes
        False
        >>> *_, two_snakes_nf = monoidal.Diagram.normalize(two_snakes)
        >>> assert double_snake == two_snakes_nf
        >>> f = Box('f', a, b)

        >>> a, b = Ty('a'), Ty('b')
        >>> double_snake = Id(a @ b).transpose(left=True)
        >>> snakes = Id(b).transpose(left=True) @ Id(a).transpose(left=True)
        >>> double_snake == two_snakes
        False
        >>> *_, two_snakes_nf = monoidal.Diagram.normalize(
        ...     snakes, left=True)
        >>> assert double_snake == two_snakes_nf
        """
        return super().normal_form(
            normalizer=normalizer or Diagram.normalize, **params)

    normalize = rewriting.snake_removal

    ty_factory = Ty


class Box(closed.Box, Diagram):
    """
    A rigid box is a monoidal box in a rigid diagram.

    Parameters:
        name : The name of the box.
        dom : The domain of the box, i.e. its input.
        cod : The codomain of the box, i.e. its output.
        z : The winding number of the box,
            i.e. the number of half-turn rotations.

    Example
    -------
    >>> a, b = Ty('a'), Ty('b')
    >>> f = Box('f', a, b.l @ b)
    >>> assert f.l.z == -1 and f.z == 0 and f.r.z == 1
    >>> assert f.r.l == f == f.l.r
    >>> assert f.l.l != f != f.r.r
    """
    __ambiguous_inheritance__ = (closed.Box, )

    def __init__(self, name: str, dom: Ty, cod: Ty, data=None, z=0, **params):
        self.z = z
        closed.Box.__init__(self, name, dom, cod, data=data, **params)

    def __str__(self):
        return str(self.r) + '.l' if self.z < 0\
            else str(self.l) + '.r' if self.z > 0 else cat.Box.__str__(self)

    def __repr__(self):
        if self.is_dagger:
            return closed.Box.__repr__(self)
        return closed.Box.__repr__(self)[:-1] + (
            ', z={})'.format(self.z) if self.z else ')')

    def __eq__(self, other):
        if isinstance(other, Box):
            return cat.Box.__eq__(self, other) and self.z == other.z
        return monoidal.Box.__eq__(self, other)

    def __hash__(self):
        return hash(repr(self))

    def rotate(self, left=False):
        dom, cod = (
            getattr(x, 'l' if left else 'r') for x in (self.cod, self.dom))
        z = self.z + (-1 if left else 1)
        return type(self)(
            self.name, dom, cod, data=self.data, is_dagger=self.is_dagger, z=z)

    @property
    def is_transpose(self):
        """ Whether the box is an odd rotation of a generator. """
        return not self.is_dagger and bool(self.z % 2)

    def drawing(self):
        result = super().drawing()
        result.is_transpose = self.is_transpose
        return result


class Sum(monoidal.Sum, Box):
    """
    A rigid sum is a monoidal sum that can be transposed.

    Parameters:
        terms (tuple[Diagram, ...]) : The terms of the formal sum.
        dom (Ty) : The domain of the formal sum.
        cod (Ty) : The codomain of the formal sum.
    """
    __ambiguous_inheritance__ = (monoidal.Sum, )

    @property
    def l(self) -> Sum:
        """ The left transpose of a sum, i.e. the sum of left transposes. """
        return self.sum_factory(
            tuple(term.l for term in self.terms), self.cod.l, self.dom.l)

    @property
    def r(self) -> Sum:
        """ The right transpose of a sum, i.e. the sum of right transposes. """
        return self.sum_factory(
            tuple(term.r for term in self.terms), self.cod.r, self.dom.r)


class Cup(BinaryBoxConstructor, Box):
    """
    The counit of the adjunction for an atomic type.

    Parameters:
        left : The atomic type.
        right : Its right adjoint.

    Example
    -------
    >>> n = Ty('n')
    >>> Cup(n, n.r).draw(figsize=(2,1), margins=(0.5, 0.05),\\
    ... path='docs/imgs/rigid/cup.png')

    .. image:: /imgs/rigid/cup.png
        :align: center
    """
    def __init__(self, left: Ty, right: Ty):
        assert_isatomic(left, Ty)
        assert_isatomic(right, Ty)
        assert_isadjoint(left, right)
        name = "Cup({}, {})".format(left, right)
        dom, cod = left @ right, self.ty_factory()
        BinaryBoxConstructor.__init__(self, left, right)
        Box.__init__(self, name, dom, cod, draw_as_wires=True)

    @property
    def l(self):
        return self.cap_factory(self.right.l, self.left.l)

    @property
    def r(self):
        return self.cap_factory(self.right.r, self.left.r)

    drawing = monoidal.Box.drawing


class Cap(BinaryBoxConstructor, Box):
    """
    The unit of the adjunction for an atomic type.

    Parameters:
        left : The atomic type.
        right : Its left adjoint.

    Example
    -------
    >>> n = Ty('n')
    >>> Cap(n, n.l).draw(figsize=(2,1), margins=(0.5, 0.05),\\
    ... path='docs/imgs/rigid/cap.png')

    .. image:: /imgs/rigid/cap.png
        :align: center
    """
    def __init__(self, left: Ty, right: Ty):
        assert_isatomic(left, Ty)
        assert_isatomic(right, Ty)
        assert_isadjoint(right, left)
        name = "Cap({}, {})".format(left, right)
        dom, cod = self.ty_factory(), left @ right
        BinaryBoxConstructor.__init__(self, left, right)
        Box.__init__(self, name, dom, cod, draw_as_wires=True)

    @property
    def l(self):
        return self.cup_factory(self.right.l, self.left.l)

    @property
    def r(self):
        return self.cup_factory(self.right.r, self.left.r)

    drawing = monoidal.Box.drawing


class Category(closed.Category):
    """
    A rigid category is a monoidal category
    with methods :code:`l`, :code:`r`, :code:`cups` and :code:`caps`.

    Parameters:
        ob : The type of objects.
        ar : The type of arrows.
    """
    ob, ar = Ty, Diagram


class Functor(closed.Functor):
    """
    A rigid functor is a monoidal functor that preserves cups and caps.

    Parameters:
        ob (Mapping[Ty, Ty]) : Map from atomic :class:`Ty` to :code:`cod.ob`.
        ar (Mapping[Box, Diagram]) : Map from :class:`Box` to :code:`cod.ar`.
        cod (Category) : The codomain of the functor.

    Example
    -------
    >>> s, n = Ty('s'), Ty('n')
    >>> Alice, Bob = Box("Alice", Ty(), n), Box("Bob", Ty(), n)
    >>> loves = Box('loves', Ty(), n.r @ s @ n.l)
    >>> love_box = Box('loves', n @ n, s)
    >>> ob = {s: s, n: n}
    >>> ar = {Alice: Alice, Bob: Bob}
    >>> ar.update({loves: Cap(n.r, n) @ Cap(n, n.l)
    ...                   >> Id(n.r) @ love_box @ Id(n.l)})
    >>> F = Functor(ob, ar)
    >>> sentence = Alice @ loves @ Bob >> Cup(n, n.r) @ Id(s) @ Cup(n.l, n)
    >>> assert F(sentence).normal_form() == Alice >> Id(n) @ Bob >> love_box
    >>> from discopy import drawing
    >>> drawing.equation(
    ...     sentence, F(sentence), symbol='$\\\\mapsto$', figsize=(5, 2),
    ...     path='docs/imgs/rigid/functor-example.png')

    .. image:: /imgs/rigid/functor-example.png
        :align: center
    """
    dom = cod = Category(Ty, Diagram)

    def __call__(self, other):
        if isinstance(other, Ty) or isinstance(other, Ob) and other.z == 0:
            return super().__call__(other)
        if isinstance(other, Ob):
            if not hasattr(self.cod.ob, 'l' if other.z < 0 else 'r'):
                return self(Ob(other.name, z=0))[::-1]
            return self(other.r).l if other.z < 0 else self(other.l).r
        if isinstance(other, Cup):
            return self.cod.ar.cups(self(other.dom[:1]), self(other.dom[1:]))
        if isinstance(other, Cap):
            return self.cod.ar.caps(self(other.cod[:1]), self(other.cod[1:]))
        if isinstance(other, Box):
            if not hasattr(other, "z") or not other.z:
                return super().__call__(other)
            z = other.z
            for _ in range(abs(z)):
                other = other.l if z > 0 else other.r
            result = super().__call__(other)
            for _ in range(abs(z)):
                result = result.l if z < 0 else result.r
            return result
        return super().__call__(other)


def nesting(cls: type, factory: Callable) -> Callable[[Ty, Ty], Diagram]:
    """
    Take a :code:`factory` for cups or caps of atomic types
    and extends it recursively.

    Parameters:
        cls : A diagram factory, e.g. :class:`Diagram`.
        factory :
            A factory for cups (or caps) of atomic types, e.g. :class:`Cup`.
    """
    def method(left: Ty, right: Ty) -> Diagram:
        if len(left) == 0:
            return cls.id(left[:0])
        head, tail = factory(left[0], right[-1]), method(left[1:], right[:-1])
        if head.dom:  # We are nesting cups.
            return left[0] @ tail @ right[-1] >> head
        return head >> left[0] @ tail @ right[-1]

    return method

assert_isadjoint = Ty.assert_isadjoint
Diagram.cup_factory, Diagram.cap_factory, Diagram.sum_factory = Cup, Cap, Sum
Id = Diagram.id
